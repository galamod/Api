using HtmlAgilityPack;
using Microsoft.AspNetCore.Mvc;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace Api.Controllers
{
    // ВРЕМЕННО ОТКЛЮЧЕН - используйте ProxyControllerSimple
    /*
    [ApiController]
    [Route("api/[controller]")]
    public class ProxyController : ControllerBase
    {
        private readonly IHttpClientFactory _httpClientFactory;
        private readonly ILogger<ProxyController> _logger;
        private const string TargetBaseUrl = "https://galaxy.mobstudio.ru/";
        public ProxyController(IHttpClientFactory httpClientFactory, ILogger<ProxyController> logger)
        {
            _httpClientFactory = httpClientFactory;
            _logger = logger;
        }

        private void AddGalaxyHeaders(HttpRequestMessage request)
        {
            // Копируем важные заголовки из входящего запроса
            if (Request.Headers.TryGetValue("Cookie", out var cookies))
            {
                request.Headers.TryAddWithoutValidation("Cookie", cookies.ToString());
            }

            // Копируем X-Requested-With (часто требуется для AJAX)
            if (Request.Headers.TryGetValue("X-Requested-With", out var xRequestedWith))
            {
                request.Headers.TryAddWithoutValidation("X-Requested-With", xRequestedWith.ToString());
            }

            // Стандартные заголовки браузера
            request.Headers.TryAddWithoutValidation("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8");
            request.Headers.TryAddWithoutValidation("Accept-Language", "ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7");
            request.Headers.TryAddWithoutValidation("Accept-Encoding", "gzip, deflate, br");
            request.Headers.TryAddWithoutValidation("Cache-Control", "no-cache");
            request.Headers.TryAddWithoutValidation("Pragma", "no-cache");

            // ВАЖНО: Для /services/ используем правильный Referer
            var referer = Request.Path.Value?.Contains("/services") == true
                ? "https://galaxy.mobstudio.ru/"
                : "https://galaxy.mobstudio.ru/";

            request.Headers.TryAddWithoutValidation("Origin", "https://galaxy.mobstudio.ru");
            request.Headers.TryAddWithoutValidation("Referer", referer);

            // Sec-Fetch заголовки (КРИТИЧЕСКИ ВАЖНО для /services/)
            request.Headers.TryAddWithoutValidation("Sec-Fetch-Dest", "empty");
            request.Headers.TryAddWithoutValidation("Sec-Fetch-Mode", "cors");
            request.Headers.TryAddWithoutValidation("Sec-Fetch-Site", "same-origin");

            // User-Agent
            request.Headers.TryAddWithoutValidation("User-Agent",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36");

            // Galaxy-специфичные заголовки (КОПИРУЕМ ИХ ИЗ ВХОДЯЩЕГО ЗАПРОСА!)
            foreach (var header in new[] { "x-galaxy-client-ver", "x-galaxy-kbv", "x-galaxy-lng",
                                     "x-galaxy-model", "x-galaxy-orientation", "x-galaxy-os-ver",
                                     "x-galaxy-platform", "x-galaxy-scr-dpi", "x-galaxy-scr-h",
                                     "x-galaxy-scr-w", "x-galaxy-user-agent" })
            {
                if (Request.Headers.TryGetValue(header, out var value))
                {
                    request.Headers.TryAddWithoutValidation(header, value.ToString());
                }
            }

            // Если заголовки не были скопированы - используем значения по умолчанию
            if (!request.Headers.Contains("x-galaxy-client-ver"))
            {
                request.Headers.TryAddWithoutValidation("x-galaxy-client-ver", "9.5");
                request.Headers.TryAddWithoutValidation("x-galaxy-kbv", "352");
                request.Headers.TryAddWithoutValidation("x-galaxy-lng", "ru");
                request.Headers.TryAddWithoutValidation("x-galaxy-model", "chrome 140.0.0.0");
                request.Headers.TryAddWithoutValidation("x-galaxy-orientation", "portrait");
                request.Headers.TryAddWithoutValidation("x-galaxy-os-ver", "1");
                request.Headers.TryAddWithoutValidation("x-galaxy-platform", "web");
                request.Headers.TryAddWithoutValidation("x-galaxy-scr-dpi", "1");
                request.Headers.TryAddWithoutValidation("x-galaxy-scr-h", "945");
                request.Headers.TryAddWithoutValidation("x-galaxy-scr-w", "700");
                request.Headers.TryAddWithoutValidation("x-galaxy-user-agent",
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36");
            }
        }

        // Универсальный метод для любых HTTP-запросов
        [HttpGet, HttpPost, HttpPut, HttpPatch, HttpDelete, HttpOptions]
        [Route("{*path}")]
        public async Task<IActionResult> HandleRequest(string path = "")
        {
            var client = _httpClientFactory.CreateClient("GalaxyClient");

            // ВАЖНО: Добавляем query string из оригинального запроса
            var queryString = Request.QueryString.HasValue ? Request.QueryString.Value : "";
            var fullPath = string.IsNullOrEmpty(path) ? "" : path + queryString;

            var targetUrl = string.IsNullOrEmpty(fullPath)
                ? new Uri(TargetBaseUrl)
                : new Uri(new Uri(TargetBaseUrl), fullPath);

            try
            {
                // 🔥 НОВОЕ: Проверяем, нужно ли проксировать этот запрос
                var needsProxy = await CheckIfProxyNeeded(client, targetUrl, path);
                
                if (!needsProxy)
                {
                    _logger.LogInformation("✅ Resource has CORS headers, redirecting directly: {Url}", targetUrl);
                    // Возвращаем редирект на оригинальный ресурс
                    return Redirect(targetUrl.ToString());
                }
                
                _logger.LogInformation("⚠️ Resource needs proxying: {Url}", targetUrl);

                // Создаём исходящий запрос
                var method = new HttpMethod(Request.Method);
                var requestMessage = new HttpRequestMessage(method, targetUrl);
                AddGalaxyHeaders(requestMessage);

                // Если есть тело запроса — копируем его
                if (Request.ContentLength > 0 &&
                    (method == HttpMethod.Post || method == HttpMethod.Put || method.Method == "PATCH"))
                {
                    // 🔥 ВАЖНО: Используем EnableBuffering для возможности повторного чтения
                    Request.EnableBuffering();
                    
                    using var reader = new StreamReader(Request.Body, leaveOpen: true);
                    var body = await reader.ReadToEndAsync();
                    Request.Body.Position = 0; // Сбрасываем позицию для возможного повторного чтения

                    var contentType = Request.ContentType ?? "application/x-www-form-urlencoded";

                    _logger.LogInformation("📦 Request body: {Body}", body.Length > 500 ? body.Substring(0, 500) + "..." : body);

                    // Определяем тип контента
                    if (contentType.Contains("application/json"))
                    {
                        requestMessage.Content = new StringContent(body, Encoding.UTF8, "application/json");
                    }
                    else if (contentType.Contains("application/x-www-form-urlencoded"))
                    {
                        requestMessage.Content = new StringContent(body, Encoding.UTF8, "application/x-www-form-urlencoded");
                    }
                    else if (contentType.Contains("text/plain"))
                    {
                        requestMessage.Content = new StringContent(body, Encoding.UTF8, "text/plain");
                    }
                    else if (contentType.Contains("multipart/form-data"))
                    {
                        // 🔥 ИСПРАВЛЕНО: Для multipart/form-data используем ByteArrayContent, а не StreamContent
                        // т.к. стрим уже прочитан
                        Request.Body.Position = 0;
                        using var memoryStream = new MemoryStream();
                        await Request.Body.CopyToAsync(memoryStream);
                        var bytes = memoryStream.ToArray();
                        
                        requestMessage.Content = new ByteArrayContent(bytes);
                        requestMessage.Content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(contentType);
                    }
                    else
                    {
                        // Любой другой тип
                        requestMessage.Content = new StringContent(body, Encoding.UTF8, contentType);
                    }
                }
                // 🔥 НОВОЕ: Обработка запросов БЕЗ Content-Length (chunked encoding)
                else if ((method == HttpMethod.Post || method == HttpMethod.Put || method.Method == "PATCH") 
                         && Request.Body.CanRead)
                {
                    try
                    {
                        Request.EnableBuffering();
                        using var reader = new StreamReader(Request.Body, leaveOpen: true);
                        var body = await reader.ReadToEndAsync();
                        Request.Body.Position = 0;
                        
                        if (!string.IsNullOrEmpty(body))
                        {
                            var contentType = Request.ContentType ?? "application/x-www-form-urlencoded";
                            _logger.LogInformation("📦 Request body (no Content-Length): {Body}", body.Length > 500 ? body.Substring(0, 500) + "..." : body);
                            requestMessage.Content = new StringContent(body, Encoding.UTF8, contentType);
                        }
                        else
                        {
                            _logger.LogInformation("⚠️ POST/PUT/PATCH request with empty body");
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, "⚠️ Failed to read request body, continuing without it");
                    }
                }

                _logger.LogInformation("Proxying {Method} request to {Url}", method.Method, targetUrl);
                _logger.LogInformation("Request headers: {Headers}",
                    string.Join(", ", requestMessage.Headers.Select(h => $"{h.Key}={string.Join(",", h.Value)}")));

                // Проксируем
                var response = await client.SendAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead);
                var contentTypeHeader = response.Content.Headers.ContentType?.ToString();
                var charset = response.Content.Headers.ContentType?.CharSet ?? "utf-8";

                _logger.LogInformation("Response status: {StatusCode}, ContentType: {ContentType}",
                    response.StatusCode, contentTypeHeader);

                // 🔥 НОВАЯ ЛОГИКА: Определяем тип запроса
                var isNavigationRequest = IsNavigationRequest(path, contentTypeHeader);
                var acceptHeader = Request.Headers["Accept"].ToString();
                var isAjaxRequest = Request.Headers["X-Requested-With"] == "XMLHttpRequest" || 
                                   acceptHeader.Contains("application/json");

                _logger.LogInformation("🔍 Request analysis: path={Path}, isNavigation={IsNav}, isAjax={IsAjax}, Accept={Accept}", 
                    path, isNavigationRequest, isAjaxRequest, acceptHeader);

                // Универсальная обработка контента
                if (contentTypeHeader != null && (
                    contentTypeHeader.Contains("text/html") ||
                    contentTypeHeader.Contains("application/json") ||
                    contentTypeHeader.Contains("application/xml") ||
                    contentTypeHeader.Contains("text/javascript") ||
                    contentTypeHeader.Contains("application/javascript") ||
                    contentTypeHeader.Contains("text/css") ||
                    contentTypeHeader.Contains("text/plain") ||
                    contentTypeHeader.Contains("application/manifest+json")))
                {
                    var text = await response.Content.ReadAsStringAsync();

                    // СПЕЦИАЛЬНАЯ ОБРАБОТКА ДЛЯ CSS
                    if (contentTypeHeader.Contains("text/css"))
                    {
                        text = Regex.Replace(text, @"url\(\s*(['""]?)(?<!https://galaxy\.mobstudio\.ru)(/web/assets/[^)'""\s]+)\1\s*\)",
                            "url($1https://galaxy.mobstudio.ru$2$1)");
                    }
                    // СПЕЦИАЛЬНАЯ ОБРАБОТКА ДЛЯ JS
                    else if (contentTypeHeader.Contains("javascript"))
                    {
                        text = Regex.Replace(text, @"(['""])(?<!https://galaxy\.mobstudio\.ru)(/web/assets/[^'""]+)\1",
                            "$1https://galaxy.mobstudio.ru$2$1");

                        text = Regex.Replace(text, @"https://galaxy\.mobstudio\.ru/(?!web/assets/)([^'""\s>]*)", "/api/proxy/$1");
                        text = Regex.Replace(text, @"(['""])(?<!https://galaxy\.mobstudio\.ru)(/web/(?!assets/)[^'""<>]*)", "$1/api/proxy$2");

                        // Внедряем скрипт автоматизации в основной JS-файл приложения
                        if (path.StartsWith("web/app.", StringComparison.OrdinalIgnoreCase) && path.EndsWith(".js"))
                        {
                            var automationScript = GetAutomationScript();
                            text = InjectScriptRandomly(text, automationScript);
                            _logger.LogInformation("✅ Automation script injected into {Path}", path);
                        }
                    }
                    // СПЕЦИАЛЬНАЯ ОБРАБОТКА ДЛЯ JSON
                    else if (contentTypeHeader.Contains("application/json") || contentTypeHeader.Contains("application/manifest+json") || path.EndsWith("manifest.json"))
                    {
                        text = Regex.Replace(text, @"""(?<!https://galaxy\.mobstudio\.ru)(/web/assets/[^""]+)""",
                            "\"https://galaxy.mobstudio.ru$1\"");

                        text = Regex.Replace(text, @"""(?<!https://galaxy\.mobstudio\.ru|/api/proxy)(/web/(?!assets/)[^""]+)""",
                            "\"/api/proxy$1\"");
                    }
                    // ОБРАБОТКА HTML
                    else if (contentTypeHeader.Contains("text/html"))
                    {
                        // 🔥 КРИТИЧНО: Если это AJAX запрос, который вернул HTML - НЕ МОДИФИЦИРУЕМ
                        // Просто возвращаем как есть (приложение само обработает)
                        if (isAjaxRequest && !isNavigationRequest)
                        {
                            _logger.LogInformation("⚠️ AJAX request returned HTML - returning as-is for app processing");
                            return Content(text, contentTypeHeader + "; charset=utf-8", Encoding.UTF8);
                        }

                        // Для HTML - обработка спецпутей в строках
                        text = Regex.Replace(text, @"(['""])/services/public/([^'""]+)\1",
                            "$1https://galaxy.mobstudio.ru/services/public/$2$1");

                        text = Regex.Replace(text, @"(['""])/web/assets/([^'""]+)\1",
                            "$1https://galaxy.mobstudio.ru/web/assets/$2$1");

                        text = Regex.Replace(text, @"url\(\s*(['""]?)/web/assets/([^)'""\s]+)\1\s*\)",
                            "url($1https://galaxy.mobstudio.ru/web/assets/$2$1)");

                        var doc = new HtmlDocument();
                        doc.LoadHtml(text);

                        RewriteRelativeUrls(doc);

                        var head = doc.DocumentNode.SelectSingleNode("//head");
                        if (head != null)
                        {
                            var oldMetas = head.SelectNodes(".//meta[@charset]") ?? new HtmlNodeCollection(null);
                            foreach (var m in oldMetas) m.Remove();
                            var httpEquivMetas = head.SelectNodes(".//meta[translate(@http-equiv,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')='content-type']") ?? new HtmlNodeCollection(null);
                            foreach (var m in httpEquivMetas) m.Remove();

                            var metaCharset = doc.CreateElement("meta");
                            metaCharset.SetAttributeValue("charset", "utf-8");
                            head.PrependChild(metaCharset);

                            var baseTag = doc.CreateElement("base");
                            baseTag.SetAttributeValue("href", "/api/proxy/web/");
                            head.PrependChild(baseTag);

                            // Внедряем скрипты ВСЕГДА для HTML страниц
                            InjectScriptsToHead(head, doc);
                        }

                        // 🔥 НОВОЕ: Убеждаемся, что в body есть контейнер .browser для services
                        if (path.StartsWith("services/") || path.Contains("/services/"))
                        {
                            var body = doc.DocumentNode.SelectSingleNode("//body");
                            if (body != null)
                            {
                                // 🔥 ИЗМЕНЕНО: НЕ создаём контейнер .browser в HTML для services
                                // Он будет создан динамически через browserApi.setup()
                                // Просто убеждаемся, что body пустой или содержит только скрипты
                                _logger.LogInformation("⚠️ Services page detected - leaving body empty for dynamic content");
                                
                                // Удаляем весь контент кроме скриптов
                                var bodyChildren = body.ChildNodes.ToList();
                                foreach (var child in bodyChildren)
                                {
                                    // Оставляем только <script> теги
                                    if (child.Name != "script")
                                    {
                                        child.Remove();
                                    }
                                }
                            }
                        }

                        var modifiedHtml = doc.DocumentNode.OuterHtml;

                        _logger.LogInformation("✅ HTML modified and returned. Size: {Size} bytes", modifiedHtml.Length);

                        return Content(modifiedHtml, contentTypeHeader + "; charset=utf-8", Encoding.UTF8);
                    }

                    // Для остальных текстовых типов просто возвращаем текст
                    return Content(text, contentTypeHeader + "; charset=utf-8", Encoding.UTF8);
                }
                else
                {
                    var content = await response.Content.ReadAsByteArrayAsync();
                    return new FileContentResult(content, contentTypeHeader ?? "application/octet-stream")
                    {
                        FileDownloadName = Path.GetFileName(targetUrl.LocalPath)
                    };
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Ошибка при проксировании запроса {Method} {Url}", Request.Method, targetUrl);
                
                // Возвращаем более детальную информацию об ошибке
                var errorDetails = new
                {
                    error = "Proxy error",
                    message = ex.Message,
                    innerException = ex.InnerException?.Message,
                    stackTrace = ex.StackTrace?.Split('\n').Take(5).ToArray(),
                    requestMethod = Request.Method,
                    requestPath = path,
                    targetUrl = targetUrl.ToString()
                };
                
                return StatusCode(500, errorDetails);
            }
        }

        // 🔥 НОВЫЙ МЕТОД: Определяет, является ли запрос навигацией
        private bool IsNavigationRequest(string path, string contentType)
        {
            // Основные признаки навигации:
            // 1. Путь к HTML странице (пустой, web/, services/)
            // 2. Content-Type содержит text/html
            // 3. Запрос НЕ к API/assets/data endpoints
            
            if (string.IsNullOrEmpty(path) || path == "web/" || path.StartsWith("web/index"))
                return true;

            if (path.StartsWith("services/") && !path.Contains("/api/") && !path.Contains("/data/"))
                return true;

            if (contentType?.Contains("text/html") == true)
                return true;

            return false;
        }

        // 🔥 НОВЫЙ МЕТОД: Проверяет, нужно ли проксировать запрос (есть ли CORS)
        private async Task<bool> CheckIfProxyNeeded(HttpClient client, Uri targetUrl, string path)
        {
            // Всегда проксируем HTML страницы и services
            if (path.StartsWith("services/") || path.EndsWith(".html") || string.IsNullOrEmpty(path))
            {
                return true;
            }

            // Всегда проксируем JavaScript и CSS (они содержат пути, которые нужно переписать)
            if (path.EndsWith(".js") || path.EndsWith(".css"))
            {
                return true;
            }

            try
            {
                // Делаем HEAD запрос для проверки CORS заголовков
                var headRequest = new HttpRequestMessage(HttpMethod.Head, targetUrl);
                headRequest.Headers.TryAddWithoutValidation("Origin", "https://galabot.tryasp.net");
                
                var headResponse = await client.SendAsync(headRequest);
                
                // Проверяем наличие CORS заголовков
                var hasAccessControlAllowOrigin = headResponse.Headers.Contains("Access-Control-Allow-Origin");
                var accessControlOrigin = headResponse.Headers.GetValues("Access-Control-Allow-Origin").FirstOrDefault();
                
                // Если есть CORS заголовок с * или нашим доменом - не нужно проксировать
                if (hasAccessControlAllowOrigin && (accessControlOrigin == "*" || accessControlOrigin?.Contains("galabot.tryasp.net") == true))
                {
                    _logger.LogInformation("✅ Resource has CORS: Access-Control-Allow-Origin={Origin}", accessControlOrigin);
                    return false;
                }
                
                _logger.LogInformation("⚠️ Resource doesn't have proper CORS headers");
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "⚠️ Failed to check CORS headers, assuming proxy needed");
                return true;
            }
        }
    }
}